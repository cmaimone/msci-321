---
title: "Week 6"
format:
  html:
    embed-resources: true
editor_options: 
  chunk_output_type: console
---

# Factors

Factors are variables with text labels, but the set of values (called levels) that are allowed for the variable is limited, and the values optionally can have a specific order to them. Categorical data is stored in R as `factor` variables. You may ask why a special data structure is needed for categorical data, when we could just use `character` variables to represent the categories.

Let's say that you've conducted a survey on students' smoking habits. The possible responses are *Never*, *Occasionally*, *Regularly*, and *Heavy*. From 10 students, you get the following responses:

```{r}
smoke <- c("Never", "Never", "Heavy", "Never", "Occasionally","Never", "Never", "Regularly", "Regularly", "No")
```

Note that the last answer is invalid - `No` was not one of the four answers that were allowed for the question. You could use `table` to get a summary of how many answers of each type that you got:

```{r}
table(smoke)
```

But the categories are not presented in the correct order! There is a clear order between the different categories, *Never* \< *Occasionally* \< *Regularly* \< *Heavy*, but `table` doesn't present the results in that way. Moreover, R didn't recognize that `No` was an invalid answer, and treats it just the same as the other categories. This is where `factor` variables come in.

**Fcators allow you to specify which values your variable can take, and the ordering between them (if any).**

### Creating Factors

When creating a `factor` variable, you typically start with a `character`, `numeric` or `logical` variable, the values of which are turned into categories. To turn the `smoke` vector that you created in the previous section into a `factor`, you can use the `factor` function:

```{r}
smoke_factor <- factor(smoke)
smoke_factor
```

You can inspect the elements, and *levels*, i.e. values that the categorical variable takes, as follows:

```{r}
levels(smoke_factor)
```

We see two problems! First, we see that "No" is a level/category, but it was not listed on our survey. To fix this problem, we can decide the categories/levels a factor vector is allowed to take by specifying the `levels` parameter in the `factor()` function call:

```{r}
smoke_factor <- factor(
  smoke,
  # allowed levels
  levels = c("Never", "Heavy", "Occasionally", "Regularly") 
)

levels(smoke_factor)
smoke_factor
```

We see that "No" is no longer listed as a level, and has been replaced by `NA` in the factor vector `smoke_factor`.

However, we still have another problem - the categories are in the wrong order.

```{r}
barplot(table(smoke_factor))

smoke_factor <- factor(
  smoke,
  # allowed levels in some desired order
  levels = c("Never", "Occasionally", "Regularly", "Heavy") 
)

barplot(table(smoke_factor))
```

Now we see the categories are in an order that is more informative. However, we still have one more problem to fix. What if we wanted to compare smokers such that:

Never \< Occasionally \< Regularly \< Heavy

i.e. if we make conditional expressions such as smoke_factor \> Occasionally, then Never and Occasionally would evaluate to FALSE while Regularly and Heavy would evaluate to TRUE. This can be helpful to subset the data meaningfully or make comparisons when the order is meaningful in some manner.

Let's see how to do this with the `ordered` parameter within `factor()`

```{r}
smoke_factor <- factor(
  smoke,
  # create allowed levels in some desired order
  levels = c("Never", "Occasionally", "Regularly", "Heavy"),
  # logical flag to determine if the levels should be regarded as ordered (in the order given) for any comparisons
  ordered = TRUE
  )

smoke_factor
```

Notice how the level information is presented differently this time to indicate possible comparisons between categories.

```{r}
smoke_factor
smoke_factor > "Occasionally"

# how many survey respondents smoke more than Occasionally
sum(smoke_factor > "Occasionally", na.rm = TRUE)
```

To recap, you can control the order in which the levels are presented by choosing which order we write them in in the `levels` argument. The `ordered = TRUE` argument specifies that the order of the variables is *meaningful*. `ordered = TRUE` can be excluded in cases where you wish to specify the order in which the categories should be presented purely for presentation purposes (e.g., when specifying whether to use the order `Male/Female/Other` or `Female/Male/Other`).

Also, note that the `No` answer now became an `NA`, which in the case of `factor` variables represents both missing observations and invalid observations. To find the values of **`smoke`** that became `NA` in **`smoke_factor`** you can use `which` and `is.na`:

```{r}
smoke
smoke_factor
is.na(smoke_factor)
which(is.na(smoke_factor))
smoke[which(is.na(smoke_factor))]
```

By checking the original values of the `NA` elements, you can see if they should be excluded from the analysis or recoded into a proper category (`No` could for instance be recoded into `Never`).

### Changing factor levels

When we created `smoke_factor`, one of the elements became an `NA`. `NA` was however not included as a level of the `factor`. Sometimes it is desirable to include `NA` as a level, for instance when you want to analyse rows with missing data. This is easily done using the `addNA` function:

Note: we'll do this with the same smoke variable we've been using, but we typically wouldn't want to add an explicit category for missing with an ordered factor, because we don't know where in the order it should belong -- as missing, it's not included in the order, but as a category, it has to fall in the order.

```{r}
levels(smoke_factor)
smoke_factor <- addNA(smoke_factor)
levels(smoke_factor)
smoke_factor
```

If you wish to change the name of one or more of the `factor` levels, you can do it directly via the `levels` function. For instance, we can change the name of the `NA` category, which is the 5th level of `smoke_factor`, as follows:

```{r}
levels(smoke_factor)
levels(smoke_factor)[5]
levels(smoke_factor)[5] <- "Invalid answer"
levels(smoke_factor)
smoke_factor
```

### Combining levels

Finally, `levels` can be used to merge categories by replacing their separate names with a single name. For instance, we can combine the smoking categories *Occasionally*, *Regularly*, and *Heavy* to a single category named *Yes*. Assuming that these are first, second and third in the list of names (as will be the case if you've run the last code chunk above), here's how to do it:

```{r}
# create our factor vector as usual
smoke_factor <- factor(
  smoke,
  levels = c("Never","Occasionally","Regularly","Heavy"),
  ordered = TRUE
  )
smoke_factor

# recode levels that are not "Never" to "Yes"
levels(smoke_factor)
levels(smoke_factor)[2:4] 
levels(smoke_factor)[2:4] <- "Yes"
levels(smoke_factor)
smoke_factor
table(smoke_factor)
```

### EXERCISE

Convert the vector below to a factor. Set the levels in an intentional order. Should ordered be set to TRUE here - why or why not?

Hint: use `table()` or `unique()` to find all the categories

```{r}
age_group <- c(
  "35-50",
  "25-34",
  "50-65",
  "65+",
  "18-24",
  "18-24",
  "50-65",
  "35-50",
  "50-65",
  "18-24",
  "18-24",
  "65+",
  "65+"
  )

# your code here               


```

### EXERCISE

Convert the variable `marital_status` in healthdata into a factor.

```{r}
healthdata <- readr::read_csv("data/nhanes.csv")

# your code here

```

### EXERCISE

Convert the variable `health_level` into an ordered factor which can be used for comparisions. Recode any missing values to "Unknown".

```{r}

```

## Factor Labels

Sometimes we have categorical variables that are encoded in our data with integer values -- for example, 0/1 indicator variables or answers like 1, 2, 3, 4, to a survey question. It's helpful to change these numerical values to text labels so we don't confuse anything. And we don't want to erroneously treat these variables as numerical when they're really categorical. We can do this with factors as well.

```{r}
my_study <- 
  data.frame(
    id = c(1:5),
    study_condition = c(0, 1, 0, 0, 1),
    outcome = c(4, 6, 3, 4, 6)
  )
my_study

table(my_study$study_condition)  # which is treatment and which is control?

my_study$study_condition <- 
  factor(my_study$study_condition, levels = c(0, 1), labels = c("control", "treatment"))

# make sure levels and labels are in the same order above, or, even better:
my_study$study_condition <- 
  factor(my_study$study_condition, labels = c("0"="control", "1"="treatment"))

table(my_study$study_condition) # much better!
```

## Forcats

Base R provides some basic tools for creating and manipulating factors. We’ll supplement these with the **forcats** package, which is part of the core tidyverse. It provides tools for dealing with **cat**egorical variables (and it’s an anagram of factors!) using a wide range of helpers for working with factors.

```{r}
library(tidyverse)
library(forcats)
healthdata <- readr::read_csv("data/nhanes.csv")
```

### Inspect factors

```{r}
# count
fct_count(healthdata$health_level)
fct_count(healthdata$health_level, sort = TRUE, prop = TRUE)

# get unique values
fct_unique(healthdata$health_level)
```

### Change the order of levels

Let's say you want to visualize the frequency counts of marital status in healthdata. While a standard barplot works, it would be more helpful the graph was ordered by category counts in increasing or decreasing order.

`fct_infreq` orders the factor levels in increasing order of frequency. While `fct_rev` simply reverses the existing order of levels.

```{r}
# marital status counts
ggplot(healthdata, aes(y = marital_status)) + 
  geom_bar()

# marital status counts - ordered by frequency
ggplot(healthdata, aes(y = fct_infreq(marital_status))) + 
  geom_bar()

# marital status counts - ordered by frequency - then reversed
ggplot(healthdata, aes(y = fct_rev(fct_infreq(marital_status)))) + 
  geom_bar()
```

Sometimes, it is useful to change the order of a factor variable based on the value of some other variable in your data.

```{r}
# cholesterol by group
healthdata %>% 
  group_by(marital_status) %>% 
  summarise(
    cholesterol = mean(cholesterol, na.rm =T)
  ) %>% 
  ggplot(aes(x = cholesterol, y = marital_status)) + 
  geom_point(size = 3) +
  ylab("Marital Status")

# cholestrol by group - ordered by cholestrol value
healthdata %>% 
  group_by(marital_status) %>% 
  summarise(
    cholesterol = mean(cholesterol, na.rm =T)
  ) %>% 
  ggplot(aes(x = cholesterol, y = fct_reorder(marital_status, cholesterol))) + 
  geom_point(size = 3) +
  ylab("Marital Status")
```

### Change the value of levels

Add NA as an explicit level

```{r}
smoke
levels(factor(smoke))
# convert missing values into a factor level
fct_na_value_to_level(smoke) %>% levels()

# ideally recode non-permissible values before adding NA as an explicit level
factor(smoke, levels = c("Never", "Occasionally", "Regularly", "Heavy")) %>% 
  fct_na_value_to_level()
```

### Combining levels

Sometimes, it is useful to lump several infrequent levels into a single level. For example, to reduce the total number of categories displayed in a plot. The argument `n` is the number of levels we want to keep.

```{r}
View(starwars)

fct_unique(starwars$skin_color) # 31 levels!

# limit to 5 most-frequent categories
starwars  %>% 
  mutate(skin_color = fct_lump(skin_color, n = 5))  %>% 
  count(skin_color, sort = TRUE)

# limit to categories representing at least 0.1 proportion of the data (10%)
starwars  %>% 
  mutate(skin_color = fct_lump(skin_color, prop = .1)) |>
  count(skin_color, sort = TRUE)

# rename the "Other" level
starwars  %>% 
  mutate(skin_color = fct_lump(skin_color, prop = .1, other_level = "extra")) |>
  count(skin_color, sort = TRUE)
```

### EXERCISE

Convert the variable `sleep_hours` into a factor to have the following levels: "less than 6 hours", "6-9 hours" and "more than 9 hours". Add NA as a level for any missing data points.

```{r}

```

### EXERCISE

Create a bar-chart visualization for the `income_poverty_ratio` by `work_status`. Order the plot by increasing value of `income_poverty_ratio`

```{r}

```

# Missing data

We've seen missing values a few times, but let's review to make sure we covered everything:

`NA` is the symbol for missing data; it can be used with any data type

```{r}
NA  
y <- c("dog", "cat", NA, NA, "bird")
y
x <- c(NA, 2, NA, 4, NA, 6, NA, 6, 6, 4)
x

is.na(y)
is.na(x)  
```

A common operation is to count how many missing values there are in a vector. We use the function `is.na()` to get TRUE when the value is `NA` and FALSE otherwise. Then we sum that result; this works because TRUE converts to 1 and FALSE converts to 0. So it counts the number of missing values (the number of TRUEs).

```{r}
sum(is.na(x))

sum(c(TRUE, FALSE))
x
sum(is.na(x))  
```

Different functions handle missing values in different ways. Most commonly, you'll get an answer of `NA` unless you tell the function to remove or exclude the missing values in the calculation.

```{r}
mean(x)
mean(x, na.rm=TRUE)
```

For data frames, remember that `is.na` can also take an entire data frame as input. Therefore, summing over each column provides the missing count for each variable in the data.

```{r}
colSums(is.na(healthdata))
```

Let's suppose you are analyzing the correlation between the first and last measurements of systolic blood pressure. However, you notice that there are missing values in these measurements. There are a few different ways to deal with them.

## Drop missing values

```{r}
healthdata %>% 
  select(bp_sys1, bp_sys3)

cor(healthdata$bp_sys1, healthdata$bp_sys3)
cor(healthdata$bp_sys1, healthdata$bp_sys3, use="pairwise.complete.obs")

# tidyverse
healthdata_subset <- 
  healthdata %>% 
  filter(!is.na(bp_sys1), !is.na(bp_sys3)) 

healthdata_subset %>% 
  select(bp_sys1, bp_sys3)

cor(healthdata_subset$bp_sys1, healthdata_subset$bp_sys3)
```

The function `complete.cases()` can be used to find which rows have no missing values at all:

```{r}
complete.cases(healthdata)
complete.cases(healthdata) %>% sum()

healthdata %>% 
  filter(complete.cases(healthdata))
```

The function `na.omit()` can be used to shorten the above calls, it directly returns the subset of data with complete cases.

```{r}
na.omit(healthdata)
```

But notice that doing so reduces your sample size from 800 observations to 573 observations. Moreover, if the data is not missing at random, you might be biasing the dataset in an unknown manner. For example, what if the missing observations differ from the non-missing observations in a manner that would affect your conclusions?

```{r}
healthdata %>% 
  group_by(is.na(bp_sys1)) %>% 
  summarise(
    across(c("age", "pulse", "cholesterol", "sleep_hours", "bp_sys2", "bp_sys3"), ~mean(.x, na.rm=T)))
```

What might you conclude from the above analysis?

## Recode or impute missing values

Imputation involves replacing missing values with estimated values such as mean, median, mode or regression predictions, to maintain dataset size and reduce bias.

For instance, you might choose to perform a mean imputation - missing values are replaced by the mean of the variable across the entire dataset.

```{r}
# calculate the mean for selected variables
healthdata %>% 
  select("age", "pulse", "cholesterol", "sleep_hours", "bp_sys1", "bp_sys2", "bp_sys3") %>% 
  summarise(across(everything(), ~mean(.x, na.rm=T)))


# check how many observations remain if all missing values are removed 
healthdata %>% 
  select("age", "pulse", "cholesterol", "sleep_hours", "bp_sys1", "bp_sys2", "bp_sys3") %>% 
  na.omit()

# check how many observations remain if all missing values are imputed 
healthdata %>% 
  mutate(
    across(
      c("age", "pulse", "cholesterol", "sleep_hours", "bp_sys1", "bp_sys2", "bp_sys3"),
      ~ifelse(is.na(.x), mean(.x, na.rm=T), .x)
    )
  ) %>% 
  select("age", "pulse", "cholesterol", "sleep_hours", "bp_sys1", "bp_sys2", "bp_sys3") %>% 
  na.omit()

```

However, we did get a hint that perhaps blood pressure measurements might not be missing at random - so is mean imputation a good idea?

Another option might be to impute based on other observations that are "neighbors" of the missing observation. This takes into consideration that there might be "sub-groups" in your data, or there might be correlations between variables such that simple imputation methods might distort the data.

## Data decisions

**When to Consider Deleting Missing Rows**:

-   **Minimal Missing Data:** If the missing data is slight and seemingly random, eliminating those incomplete entries is unlikely to significantly affect the dataset's overall quality.

-   **MCAR Data:** Deletion is most appropriate when the missing data is Missing Completely At Random (MCAR), meaning there's no systematic difference between the missing and observed values.

    Optionally you could perform:

    **Partial imputation:** Choose to impute only certain columns if other columns just have trivial missingness.

    **Whole data imputation:** Choose to impute only certain columns if other columns just have trivial missingness. However, in this case it is important to ensure that data are MCAR, and that any claimed statistical results stand irrespective of the method chosen for imputing values.

See [this resource](https://dept.stat.lsa.umich.edu/~jerrick/courses/stat701/notes/mi.html) for imputation decisions and how to do advanced imputing in R.

### EXERCISE

Compute `n_missing` and `pct_missing` for every column in healthdata. List the **top 10** variables by `pct_missing`.

```{r}

```

**Check your work**: Are there variables with *very high* missingness (e.g., \> 50%)?

### EXERCISE

Compute the percentage of missing data for `cholestrol` by age_decade. Also compute the mean `cholestrol` for each group.

```{r}

```

**Check your work**: Are the percentages similar across groups, or noticeably different? Is cholesterol correlated with age-group?

### EXERCISE

Impute the missing values in `pulse`. You can impute by any method you choose.

```{r}

```

**Check your work**: Is pulse Missing Completely At Random MCAR in the data? How would you check this?
