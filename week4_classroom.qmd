---
title: "Week 4"
format:
  html:
    embed-resources: true
editor_options: 
  chunk_output_type: console
---

Load your packages and import the data:

```{r}
library(dplyr)
healthdata <- read.csv("data/nhanes.csv")
```

# Tidyverse

We've seen a few tidyverse functions that are useful when working with data frames: `select()`, `filter()`, `mutate()`, `rename()`. These functions can be useful on their own, but they're most useful when combined together into multi-step workflows.

## Intro to Tidy data

Tidy data is data where:

1.  Each variable is a column; each column is a variable.

2.  Each observation is a row; each row is an observation.

3.  Each value is a cell; each cell is a single value.

Tidy data describes a standard way of storing data that is used wherever possible throughout the [tidyverse](https://www.tidyverse.org/). If you ensure that your data is tidy, you'll spend less time fighting with the tools and more time working on your analysis.

## Tibbles

Let's start by loading the tidyverse set of packages, and using the `read_csv()` function from the readr package to load the dataset instead of using the built-in `read.csv()` function

```{r}
library(tidyverse)

healthdata <- read_csv("data/nhanes.csv")
```

`read_csv()` makes slighly different assumptions about the data when importing than `read.csv()`. For example, it reads in all numeric variables as the numeric type instead of using the integer type for some variables.

For data sets that include dates or other special types of data, `read_csv()` often handles and automatically converts such data into appropriate types well.

The biggest difference between `read_csv()` and `read.csv()` is that `read_csv()` results in a tibble, which is a data frame with some additional features.

```{r}
healthdata
```

The most obvious difference between a tibble and a regular data frame is that the output of a tibble in the console is limited to what fits.

To view the entire data frame, use the `View()` function:

```{r, eval=FALSE}
View(healthdata)
```

## Review

We've seen 3 key functions from the dplyr package already:

-   `select()`: to choose columns
-   `filter()`: to choose rows
-   `mutate()`: to create a column or alter an existing column

As well as:

-   `rename()`: to change the name of existing columns
-   `arrange()`: to sort the data frame by selected columns

Remember that we do not need quotes around column names inside of these functions.

```{r, eval=FALSE}
select(healthdata, gender, age)
filter(healthdata, age > 40)
mutate(healthdata, senior = age >= 65)
arrange(healthdata, age)
```

We're going to add a few more functions to this set, and learn how to combine them together using the pipe operator (`%>%` or `|>`).

## Summarize

We've seen how to subset a data frame with dplyr functions, but how do we compute summary statistics, like a mean? `mutate()` is for changing an entire column in a data frame (either an existing one or creating a new one). `summarize()` is for computing single values, such as a mean or median.

```{r}
summarize(healthdata, mean_age = mean(age))
```

The result is still a data frame.

You can compute multiple summary measures at the same time:

```{r}
summarize(healthdata, 
          mean_age = mean(age),
          mean_weight = mean(weight, na.rm=TRUE))
```

## TRY IT

Compute the mean and median of both bp_sys1 and bp_sys2

```{r}

```

### Across

If we want to apply the same summary functions to multiple columns in our data frame, we can write out all of the summary commands explicitly, or we can use `across()` to select which variables to summarize with which functions. `across()` selects columns using the helper functions you could give to `select()` directly.

```{r}
na.omit(healthdata) %>% 
  summarize(across(where(is.numeric), mean))
```

#### Selecting columns using their names

If you wanted to select columns using their names, put them in a vector (so it's a single input argument):

```{r}
na.omit(healthdata) %>% 
  summarize(across(c(sleep_hours, weight), mean))
```

#### Apply multiple functions to each column

If we want to apply multiple functions to each column, we put their names in a list() together:

```{r}
na.omit(healthdata) %>% 
  summarize(across(where(is.numeric), list(mean, sd)))
```

To fix the names in the output, explicitly name our summary functions in the list:

```{r}
na.omit(healthdata) %>% 
  summarize(across(where(is.numeric), list(avg=mean, std=sd)))
```

### TRY IT

Calculate the mean and standard deviation for all numeric columns in the healthdata.

```{r}

```

## Multi-step Operations

What about computing summary statistics on a subset of the data? To do that, we need to combine multiple functions. Use the pipe operator (`%>%` or `|>`) to combine multiple commands.

A simple version is to subset the observations that we want to use with `filter()`:

```{r}
healthdata %>%
  filter(gender == "male") %>%
  summarize(mean_weight = mean(weight, na.rm=TRUE))
```

A more complicated example is to change a variable with `mutate()` (just temporarily) to use in a calculation. For example, let's convert weight from kg to pounds before computing the mean:

```{r}
healthdata %>%
  filter(gender == "male") %>%
  mutate(weight = weight * 2.2) %>%
  summarize(mean_weight = mean(weight, na.rm=TRUE))
```

Compare this to the base R code for the same operation:

```{r}
mean(healthdata$weight[healthdata$gender == "male"] * 2.2, na.rm=TRUE)
```

## TRY IT

Compute the median pulse for female participants.

```{r}

```

## Working with Groups

Above, we computed summary statistics for particular subgroups. But it would be nice to compute them for all subgroups at once -- for example, for both male and female participants. Use `group_by()` as part of a multi-step operation to do that:

```{r}
healthdata %>%
  group_by(gender) %>%
  summarize(mean_weight = mean(weight, na.rm=TRUE))
```

We get one row of output for each distinct value of the variable we grouped by.

We can also group by multiple variables:

```{r}
healthdata %>%
  group_by(age, gender) %>%
  summarize(mean_weight = mean(weight, na.rm=TRUE))
```

The rows have all combinations of the two grouping variables that exist in the data.

### Ungrouping

If you ever have a grouped data frame, you may need to ungroup it to get rid of the groups. To do so, use `ungroup()`:

```{r}
healthdata %>% 
  group_by(gender) %>% 
  ungroup()
```

Usually this would come up after more complicated operations, and often after computing summary measures by group.

## TRY IT

Compute the mean of `bp_sys1` by `age_decade`

```{r}

```

# Count

A common summary value to compute is the number of observations in a group (like you get with `table()`). To compute counts using dplyr functions, we can use `count()` and `n()`:

First, use `count()` to make a frequency table:

```{r}
healthdata %>%
  count(gender)
```

```{r}
healthdata %>%
  count(gender, age_decade)
```

If we want the count along with other values, we can use `n()` with `summarize()`:

```{r}
healthdata %>%
  group_by(gender) %>%
  summarize(n = n(), 
            mean_pulse = mean(pulse, na.rm=TRUE))
```

## TRY IT

How many participants have each work_status?

```{r}

```

### n()

A useful helper function with summarize is n() which counts the number of rows. It can be useful in computing proportions.

```{r}
healthdata %>% 
  mutate(sleep_enough = if_else(sleep_hours >= 8, 1, 0)) %>% 
  summarize(
    sleep_enough_count = sum(sleep_enough == 1, na.rm = TRUE),
    total_obs = n(),
    sleep_enough_prop = sleep_enough_count / n()
  )
```

### TRY IT

Calculate the proportion of people that have a cholesterol level higher than 5 mmol/L

```{r}

```

## Computing Proportions

Knowing the number of observations in each group is useful, but we often want to know the proportion as well. We can compute proportions by summing the group counts, and dividing each by the sum:

```{r}
healthdata %>%
  count(gender) %>%
  mutate(prop = n / sum(n))
```

Or, if you want to compute other summary statistics at the same time:

```{r}
healthdata %>%
  group_by(gender) %>%
  summarize(mean_pulse = mean(pulse, na.rm=TRUE),
            n = n()) %>%
  mutate(prop = n / sum(n))
```

For simple cases, the equivalent with built-in functions is:

```{r}
table(healthdata$gender) / nrow(healthdata)

# or 
prop.table(table(healthdata$gender))
```

## TRY IT

What proportion of participants have each `marital_status`?

```{r}

```

## tabyl

The `tabyl()` function in the janitor package is useful for computing tables with counts and proportions. It uses a tidyverse syntax, taking a data frame as the first input and the unquoted name of the column(s) as additional inputs.

```{r}
# install.packages("janitor")
library(janitor)

tabyl(healthdata, gender)
```

With two variables, you just get counts:

```{r}
tabyl(healthdata, gender, work_status)
```

## Row-wise operations

dplyr is better suited to perform operations over columns. Performing operations over rows is more difficult.

### `rowwise` as a special type of grouping

```{r}
healthdata %>% 
  rowwise()
```

Notice that the output tells you that it's grouped rowwise. This is a special type of grouping where each group consists of a single row.

Like `group_by`, `rowwise` is not useful by itself, but when you combine it with some of the other `dplyr` functions. Let's take a look at how it changes the behavior of `mutate`:

```{r}
healthdata %>% 
  mutate(bp_dia_avg = mean(c(bp_dia1, bp_dia2, bp_dia3), na.rm = TRUE)) %>% 
  select(contains("dia"))
```

It computed the mean of each column across all rows. Not what we wanted!

```{r}
healthdata %>% 
  rowwise() %>% 
  mutate(bp_dia_avg = mean(c(bp_dia1, bp_dia2, bp_dia3), na.rm = TRUE)) %>% 
  select(contains("dia"))
```

Now it computed the mean for each group/row, which is what we wanted!

### Summary statistics per row

You can also use `rowwise` in combination with `summarize` to calculate summary statistics per row:

```{r}
healthdata %>% 
  rowwise() %>% 
  summarize(bp_dia_avg = mean(c(bp_dia1, bp_dia2, bp_dia3), na.rm = TRUE))
```

### TRY IT

Using `example_df` below, use `mutate` or `summarize` to calculate the sum of `w`, `x`, `y`, and `z` per row.

Challenge: use [`c_across`](https://dplyr.tidyverse.org/reference/c_across.html) to avoid typing all the column names.

```{r}
example_df <- tibble(id = 1:6, w = 10:15, x = 20:25, y = 30:35, z = 40:45)
example_df
```
