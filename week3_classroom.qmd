---
title: "Week 3"
format:
  html:
    embed-resources: true
editor_options: 
  chunk_output_type: console
---

# Recap

## Functions

Functions have a name. They optionally take one or more input values (arguments). They optionally return a value (or a more complicated object) or have a side effect (do something).

Example functions: `log`, `round`.

Note that you can nest function calls:

```{r}
log(16)
round(2.12345)
round(log(16))
```

In `round(log(16))` for example R first evaluates `log(16)` and then evaluates `round()` on that result.

How do you learn function names? See the [R Reference Card](https://cran.r-project.org/doc/contrib/Baggott-refcard-v2.pdf) for some basics. Otherwise, look at the documentation for the packages you're using, or tutorials for the type of analysis you want to do. Google is always there for you!

The inputs or arguments to a function have names. When we don't use the name, like above, it matches the values in order. But we can always use the argument name:

```{r}
round(3.1415, digits=2)
```

You can find the argument names in the Help or documentation page for the function. We'll look at these soon.

## Packages

R comes with lots of built-in basic functions (commands). But we almost always need to use functions from additional packages as well.

-   Packages contain additional functions, and sometimes data sets
-   Install packages once (for each major version of R)
-   To update a package, re-install it
-   Load packages in each R session where you want to use them

### Installing a package

-   RStudio often prompts you to install packages you're missing: if you open a file that uses a package that you don't have installed
-   Do NOT put installation commands in R scripts or R Markdown/Quarto files (included below only because we're teaching)

```{r, installpackages, eval=FALSE}
# install a single package
install.packages("praise")

# install a few at once (put names in a vector)
install.packages(c("palmerpenguins", "tidyverse", "janitor"))
```

Packages are installed from a repository. CRAN (Comprehensive R Archive Network) is the most common. People also install packages from Bioconductor and GitHub (process differs for these).

The Packages tab in the bottom right of RStudio can help you install and update packages.

If you're asked a question about whether you want to install packages from source, say NO. This is because installing from source requires compiling into computer-readable documents which take time. If you say NO then R uses a pre-compiled version.

### EXERCISE

Write code to install these packages:`praise`, `palmerpenguins`, `janitor`, `tidyverse`, `RColorBrewer`, `ggpubr`, `gridExtra`, and `grid`.

```{r, installpackagesworkshop, eval=FALSE}

```

### Using Packages

Packages have additional functions in them. Go to the Packages tab to take a look. Click on a package name to pull up the package index.

To use a package in your current session, use the `library()` function to load all of the functions (and other objects) in the package into your environment. You need a separate library command for each package. You do not need quotes around the package names. Put these at the top of your script or R Markdown file so people (collaborators or your future self) can see which packages are needed for the code.

Only load the packages you need. Packages can conflict with each other, so don't load ones you aren't using.

```{r}
library(praise)
library(palmerpenguins)
```

Now that we loaded `praise`, we can use functions within it!

```{r}
praise()
```

# Data Frames: Change Column Names

```{r}
# data import
library(dplyr)
healthdata <- read.csv("data/nhanes.csv")
```

We get the current names of variables/columns in a data frame with `names()`:

```{r}
names(healthdata)
```

The output is a vector, so we can also reference individual elements of the result:

```{r}
names(healthdata)[2]
```

Changing the name of a column involves a slightly weird syntax: we use `names()` on the left-hand side of an assignment operation.

To change the name of the second column to "year", we select the value we want to change, and then assign a new value to it:

```{r}
names(healthdata)
names(healthdata)[2] <- "year"
names(healthdata)
```

You can change multiple value at once as well:

```{r}
names(healthdata)
names(healthdata)[2:3] <- c("year", "participant_gender")
names(healthdata)
```

## rename()

The `rename()` function from the dplyr package also allows you to rename columns, with a slightly easier syntax. `rename()` takes a data frame as input and returns the whole data frame with the columns renamed as output. The syntax is:

```{r, eval=FALSE}
rename(data_frame, new_name = old_name)
```

Example:

```{r, eval=FALSE}
rename(healthdata, year = survey_year)
names(rename(healthdata, year = survey_year))  # to see the names

# rename multiple columns at once
rename(healthdata, year = survey_year, systolic = bp_sys1)
```

To make the changes stay, assign the output back to the original data frame variable name:

```{r}
healthdata <- rename(healthdata, year = survey_year)
```

Let's change the name back:

```{r}
healthdata <- rename(healthdata, survey_year = year)
```

## Valid Names

Variable names in R need to start with a letter (or, technically, a letter or a period, but don't use a period). They can contain letters, numbers, underscores, and periods. A good convention, or style, to use is to name variables in all lower case letters and numbers, using underscores (`_`) to separate words in the name as needed.

Variable names are case sensitive.

Sometimes, we might import a dataset that has column names that don't conform to the requirements. For example, the column names might start with a number or have spaces in them. When data with invalid names is imported with `read.csv()`, by default it will add an "X" to the beginning of variable names if needed, and replace spaces with a period. Other data import functions, such as `read_csv()` from the readr/tidyverse package, leave the names unchanged by default.

What happens when we use a name that doesn't conform to the specifications for a column in a data frame? Here's an example:

```{r}
names(healthdata)[1] <- "123"
names(healthdata)
```

The above is OK so far, but when we try to access the column:

```{r, eval=FALSE}
# gives an error
healthdata$123
```

Note that "123" above is blue in the code highlighting in RStudio because it looks like a number. We'd also get errors or unintended behavior trying to use a variable named "123" with functions like `select()`.

Invalid names have to be surrounded by backticks to use them with `$` or in functions that reference the column names unquoted. If we wanted to reference this variable, we'd need to do:

```{r}
healthdata$`123`
select(healthdata, `123`)
```

But this is annoying. It's best to clean up any invalid names either before importing the data file or immediately after

Let's fix the name before moving on:

```{r}
names(healthdata)[1] <- "id"
```

### Tip: clean_names()

There is a function called `clean_names()` in the janitor package that takes a data frame as input and returns a data frame as output, with the column names cleaned up: names are converted to all lower case, with underscores where there were any spaces; characters are converted to ASCII equivalents (for example, Ã© becomes e); an "x" will be added before any names starting with a number. Other clean up options are also available. Even if a data frame has valid names, this function can be useful to standardize them all to the same style and standards.

# Data Frames: Change the Values of an Existing Column

How we modify an existing variable in the data frame depends on whether we want to change all of the values or just specific values (like `NA`).

## Changing All Values

If we can use a function or operation that will return either a single value that we want to use for ALL rows, or a vector of the same length as the original variable (the number of rows in the data frame), we can assign the new value(s) to the column vector.

For example, the weight variable in the dataset is in kg. Multiply all of the values by 2.2 to convert it to pounds:

```{r}
healthdata$weight <- healthdata$weight * 2.2
```

## Modifying Column Types

One specific way we might change all of the values in a variable/column is by changing the data type of the column. There is a series of functions that will convert data to a specific type. For example: `as.character()`, `as.numeric()`, `as.integer()`, `as.logical()`

The id variable is currently a numeric (integer) type. But we wouldn't want to use it as a number. Let's convert it to character data:

```{r}
head(healthdata$id)
healthdata$id <- as.character(healthdata$id)
head(healthdata$id)
```

## mutate()

We can also change variables with the `mutate()` function from the dplyr package. `mutate()` returns a copy of the data frame with the modification. To make this change affect the data frame for future operations, we need to save the result back to the data frame:

```{r}
# just return a modified copy
mutate(healthdata, height = height / 2.54)  # convert cm to inches

# save the change
healthdata <- mutate(healthdata, height = height / 2.54)
```

## TRY IT

Change back the variables we modified above: divide weight by 2.2, multiply height by 2.54, and convert the id variable back to an integer type

```{r}

```

## Tip: What if you make a mistake?

What if you make a mistake and mess up your data frame? Just import the data again, and re-run any other code you may have written. This is one reason we keep track of what we do in an R script or notebook.

```{r}
healthdata <- read.csv("data/nhanes.csv")
```

## Changing Specific Values

To change just specific values in a column, we select the values we want to change, and then assign a new value to them. This is most commonly done when we want to recode one or just a few specific values.

For example, we could replace missing `NA` values in a variable with a special code:

```{r}
head(healthdata$bp_sys1, n=20)  # see that there are missing
healthdata$bp_sys1[is.na(healthdata$bp_sys1)] <- 9999
head(healthdata$bp_sys1, n=20)  # check that they changed
```

The above is just an example - usually we'd be recoding values like 9999 to `NA` instead!

```{r}
# change it back
healthdata$bp_sys1[healthdata$bp_sys1 == 9999] <- NA
```

We could supply a vector, instead of a single value, on the right, but it can be easy to make a mistake that way if the length of the two sides doesn't match up correctly.

Note that this approach doesn't work with `mutate()`. `mutate()` always requires the right-hand side of the assignment to be either a single value or a vector of the same length as the original.

## ifelse()

Subsetting a vector and then assigning a value to that subset can be a bit cumbersome. The `ifelse()` function allows us to use the same syntax as if we were changing all of the values in a vector, while only changing some. `ifelse()` also works with `mutate()`.

`ifelse()`allows you to change the values of a vector based on a conditional test.

```{r, eval=FALSE}
ifelse(test_condition, value_if_true, value_if_false)
```

Example:

```{r}
ifelse(healthdata$sleep_hours >= 8, "8+ hours", "<8 hours")
```

To use `ifelse()` to modify the values of a vector, a common use is:

-   if some condition is TRUE,
-   then return a new value
-   otherwise return the original value

This code will recode all `NA` values in `healthdata$bp_sys1` to 9999 and leave all other values unaffected:

```{r}
healthdata$bp_sys1 <- ifelse(is.na(healthdata$bp_sys1), 9999, healthdata$bp_sys1)

# or 
mutate(healthdata, by_sys1 = ifelse(is.na(bp_sys1), 9999, bp_sys1))
```

If the test condition results in `NA`, then the output of `ifelse()` is `NA`.

## TRY IT

1.  Use `ifelse()` to recode the 9999 values in bp_sys1 to `NA`

2.  Recode missing values in `healthdata$health_level` to "Unknown" using `ifelse()`

```{r}

```

# Data Frames: Add a Column

To add a column, simply name it and assign a value to it:

```{r}
healthdata$long_sleeper <- healthdata$sleep_hours > 8
names(healthdata)

# or
mutate(healthdata, long_sleeper = sleep_hours > 8)
```

The column will be added to the far right of the data frame.

# Data Frames: Removing Rows or Columns

To remove rows or columns from a data frame, create the subset of the data frame that you want, and then assign that result to a variable -- either the same data frame name to overwrite the original data frame (only in the R session, it doesn't change the file) or to a new name.

```{r}
males <- healthdata[healthdata$gender == "male", ]
```

Avoid saving multiple subsets of the data with different names. Having multiple copies or versions of a dataset in the environment makes your code harder to follow, can result in mistakes by choosing or modifying the wrong subset, and can use a lot of memory with larger data sets. Instead, subset or modify the data just when needed.

# Data Frames: Reorder Columns

Most of the time, there is no need to reorder columns in a data frame. If you want to, you can subset the columns in the order you want, and then reassign the result back to the same variable name.

Example:

```{r}
healthdata <- healthdata[ , c(4, 2, 3, 1, 5:ncol(healthdata))]
```

`5:ncol(healthdata)` selects the 5th through the last column.

## select()

The `select()` function from dplyr can also be used to reorder columns. There's a helper function, `everything()`, that is a convenient shorthand for including all other columns beyond the ones named, putting them at the end in the original order:

```{r}
select(healthdata, age, age_decade, gender, everything())
```

# Pipe Operator

As you put together more complex expressions with R, nesting function calls can make code hard to read, because it flips the order of the steps: the last operation ends up on the outside.

Instead, we can use a "pipe" operator to chain together commands in order. The operator takes the output from a command on the left and makes it the first input to the function on the right.

The built-in version of this operator is `|>`. Another version of the operator that is commonly used, which comes from a package that's installed with tidyverse, is `%>%`. `%>%` has some additional capabilities that `|>` doesn't, but they work the same for the situations we'll discuss here.

```{r}
# instead of:
round(log(10))

# with pipe
log(10) |> round()
log(10) %>% round()
```

The left hand side, `log(10)` is computed, and the output becomes the first input to the `round()` function on the right hand side.

Other inputs can also be used:

```{r}
log(10) |> round(digits=3)
```

Using the pipe operator means that we can think about the steps we need to take with the data, and then have those steps show up in that order in the code.

::: callout-tip
## RStudio Tip: Pipe Shortcut

The keyboard shortcut to type a pipe operator in RStudio is Ctrl + Shift + M (Windows) or Cmd + Shift + M (Mac). This will insert `%>%` by default. To change to `|>`, go to the Tools menu \> Global Options \> Code \> Use Native Pipe Operator
:::

## TRY IT

Convert the following expression to use the pipe operator instead:

```{r}
max(round(healthdata$weight), na.rm=TRUE)


```

## Pipe with Tidyverse

dplyr functions, like `select()`, `filter()`, and `mutate()` take a data frame as their first input and return a data frame. This means they can be chained together easily with the pipe operator.

```{r}
filter(healthdata, gender == "male") %>%
  select(height, weight)
```

Note that the data frame name is omitted from `select()` because the data frame that results from `filter()` is that first input because of the pipe operator.

To make it clearer what data frame you're working with, it's common to put the data frame by itself at the start of a chain of dplyr commands:

```{r}
healthdata %>%
  filter(gender == "male") %>%
  select(height, weight)
```

Remember: Order matters - if you want to filter using a particular column, make sure you don't remove it with select before the filter step ðŸ˜€

## TRY IT

Subset the healtdata data frame to contain the the education and marital_status for participants younger than 22.

```{r}

```

# Save a Data Frame

To save a data frame to a CSV file, use the `write.csv()` function.

```{r, eval=FALSE}
write.csv(healthdata[healthdata$gender == "male", ], 
          file="male_respondents.csv",
          row.names = FALSE)  # don't number the rows in the output
```

The file is saved in your working directory; include directories in the file path to direct the output elsewhere.

If you want to work with the resulting file in Excel, it's still recommended to save a CSV file, instead of an Excel file, as Excel can easily open a CSV file.

It is HIGHLY recommended to save a data frame to a new file; do NOT overwrite the original CSV or Excel file that you read into R and modified (meaning use a different file name when you save the file). Overwriting the original file would prevent you from undoing any changes and prevents you from replicating your workflow, since the complete workflow would use two different versions of the same file.

# Working with Text

## paste()

`paste()` is used to join, or concatenate, pieces of text together into a single string. It works element-wise on vectors.

```{r}
paste("Participant", healthdata$id, "is", healthdata$age, "years old")
```

The default separator between the elements is a space.

```{r}
paste(healthdata$gender, healthdata$age, sep=", ")
```

There is a shorthand for the common situation where you want to join the pieces of text without any separator between them: `paste0()`

```{r}
paste0(healthdata$height, "cm")
```

## TRY IT

Format `bp_sys1` and `bp_dia1` in a blood pressure reporting format, like 120/80

```{r}

```

## str_replace()

To edit character/text data, functions from the `{stringr}` package (which is installed as part of tidyverse), are helpful - to replace a character or substring use `str_replace`:

```{r}
library(stringr)

str_replace(healthdata$age_decade, "-", " to ")
```

If you know regular expressions for pattern matching, the `{stringr}` functions can be used with regular expressions as well. (Regular expressions are really useful if you work with text data.)

If you want to remove a character or substring instead of replace it, use `str_remove()` instead.

## TRY IT

Replace the underscore "\_" in survey_year with a dash "-"

```{r}

```

# Sorting

To sort the values of a vector, use `sort()`:

```{r}
sort(healthdata$age)
sort(healthdata$age, decreasing = TRUE)
```

`NA` values are dropped by default when sorting:

To sort the rows in a data frame, use the `arrange()` function from the dplyr package:

```{r}
arrange(healthdata, age)
arrange(healthdata, desc(age))

arrange(healthdata, age, pulse)
```

# Unique Values

## unique()

`unique()` returns the set of distinct values in a vector:

```{r}
unique(healthdata$sleep_hours)
```

`NA` is included as a value.

If you use `unique()` on a data frame instead of on a vector, it drops fully duplicate rows.

To get the unique values in sorted order, combine with `sort()`:

```{r}
sort(unique(healthdata$sleep_hours))
```

Note that when sorting, `NA` values are dropped.

To count the number of distinct values, combine with `length()`:

```{r}
length(unique(healthdata$sleep_hours))
```

## n_distinct()

The `n_distinct()` function from the dplyr package is a useful shortcut when you want `length(unique(...))`:

```{r}
n_distinct(healthdata$sleep_hours)
```

# Generating Vectors

Generating a vector with a specific sequence of values in it can be useful for some data cleaning/manipulating tasks, and when doing more complex programming or creating simulations in R.

## :

You've already seen the colon operator when subsetting vectors and data frames:

```{r}
1:4
-4:7
```

This creates a vector of integers inclusive of the start and end values. This can be useful if you want to number the rows in a data frame.

## seq()

The `seq()` (sequence) function generalizes what you can do with `:` by allowing you to use values other than integers and specify the spacing between values:

```{r}
seq(from=0, to=1.5, by=.25)
```

```{r}
seq(0, 3, by=.7)
```

The first value in the output will be the first value (`from`) of the input. The last value of the output will be the last valid value in the sequence less than or equal to the `to` value in the input. There are some additional special cases and variants on how to use the function that you can read about in the documentation.

## rep()

`rep()` (repeat) builds a vector by repeating elements a specified number of times:

```{r}
rep("a", 4)
rep(c("a", "b"), 4)       # repeats the whole vector 4 times
rep(c("a", "b"), each=4)  # repeats each element 4 times
```

You can also specify more complicated patterns. For example:

```{r}
rep(6:9, times=1:4)
```

The first element (6) is repeated 1 time, the second (7) is repeated 2 times, and so on.
